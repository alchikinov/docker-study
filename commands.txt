task 1 commands

# Create image from dockerfile
# docker build -t alchikinov/postgres-with-init . -f Dockerfile-postgres

# Run container from newly created image
# docker run --name postgres -e POSTGRES_PASSWORD=mysecretpassword alchikinov/postgres-with-init

# Inspect that conteiner and get ip address
# docker inspect postgres
# get IPAddess: 172.17.0.2

# Run different container from originat postgrase image to get access to tables
# not convinient way, just check that it is work
# docker run -it --rm postgres psql -h 172.17.0.2 -U postgres
# - enter the password: mysecretpassword
# \dt
# to quit \q

# Working with networks. Stop working container, view network list, add new network
# docker network list
# docker ps <- to get container name
# docker rm -f a20082c6d576

# Creating bridge network
# docker network create postgres-network
# docker run --name postgres-db -e POSTGRES_PASSWORD=mysecretpassword --network postgres-network alchikinov/postgres-with-init
# docker inspect postgres-network <- to check getway
# docker inspect postgres-db <- to get IP

# get by IP
# docker run -it --rm --network postgres-network postgres psql -h 172.18.0.2 -U postgres

# get by name
# docker run -it --rm --network postgres-network postgres psql -h postgres-db -U postgres

# access from local terminal with port
# to run with port
# docker run --name postgres-db -e POSTGRES_PASSWORD=mysecretpassword --network postgres-network -p 3000:5432 alchikinov/postgres-with-init

# to access from local terminal
# psql -h localhost -U postgres-db -p 3000

# network host
# docker run -it --rm --network host  postgres psql -h localhost -U postgres-db -p 3000

# network none
# docker run --name postgres-db -e POSTGRES_PASSWORD=mysecretpassword --network none alchikinov/postgres-with-init

# to get files from isolated container
# docker exec [conteiner id] ls


task 2 (3) commands
# Create network -> webapp-backend
# docker network create webapp-backend

# Build backend from Dockerfile
# docker build -t alchikinov/webapp-backend .

# Run container 
# docker run --rm --name webapp-backend --network webapp-network -p 5001:5050 alchikinov/webapp-backend

# Run container from postgres original image
# docker run --name postgres-db --network webapp-network --rm -v $PWD/init.sql:/docker-entrypoint-initdb.d/init.sql -p 5432:5432 -e POSTGRES_PASSWORD=mysecretpassword -e POSTGRES_DB=mydatabase postgres

# check FE http://localhost:5001/api/data

task 4

# docker build -t alchikinov/webapp-frontend .
# docker run --rm --name webapp-frontend --network webapp-network -p 3000:3000 alchikinov/webapp-frontend
# docker run --rm --name webapp-backend --network webapp-network -p 5050:5050 alchikinov/webapp-backend

# multi stage run
# docker build -t alchikinov/webapp-frontend-multi-stage .
# docker run --rm --name webapp-frontend-multi-stage -p 3001:80 alchikinov/webapp-frontend-multi-stage

task 5
# docker build -t alchikinov/api-tests-base . -f Dockerfile-base

# docker run -it --rm alchikinov/api-tests-base sh
# ls
# pwd

task 6
# docker build -t alchikinov/api-tests-runner . -f Dockerfile-runner

# docker run -it --rm alchikinov/api-tests-runner sh
# to run test
# cucumber PLATFORM=DEV

# docker run --rm alchikinov/api-tests-runner cucumber PLATFORM=DEV
# docker run --rm --network host alchikinov/api-tests-runner cucumber PLATFORM=PRD

# push to docker hub
# docker tag webapp-frontend:latest alchikinov/webapp-frontend
# docker push alchikinov/webapp-frontend


# docker compose up
# docker stats
# docker compose down

# if container failing, do inspect to see reasone and additional information (RestartCount)
# docker inspect [container]

# docker compose up --build --no-deps api-tests
# docker compose up --build
# docker logs [container]

#kuberketes
# minikube start
# minikube tunnel
# docker stats

# minikube dashboard


kubectl get pods
kubectl get deployments
kubestk get 

#kubectl create -f [path to the yml file]

# kubectl create -f k8s/database/deployments.yml

# kubectl delete deployment [deployment name]
# kubectl applay -f [path to the yml file]

# kubectl get services

# kubectl logs [pod name]
# kubectl exec -it [pod name] -- sh

# kubectl replace --force -f k8s/backend/deployment.yml

# sudo lsof -i -P | grep LISTEN | grep :$PORT
# docker build -t mtararujs/webapp-frontend:v3 .
# kubectl set image deployment frontend-deployment-dev frontend-dev=alchikinov/webapp-frontend-multi-stage:v3


 